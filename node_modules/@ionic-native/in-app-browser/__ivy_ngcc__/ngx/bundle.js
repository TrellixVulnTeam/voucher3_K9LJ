'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var core$1 = require('@angular/core');
var core = require('@ionic-native/core');
var rxjs = require('rxjs');

var ɵngcc0 = require('@angular/core');
var InAppBrowserObject = /** @class */ (function () {
    /**
     * Opens a URL in a new InAppBrowser instance, the current browser instance, or the system browser.
     * @param {string} url     The URL to load.
     * @param {string} [target="self"]  The target in which to load the URL, an optional parameter that defaults to _self.
     *                 _self: Opens in the WebView if the URL is in the white list, otherwise it opens in the InAppBrowser.
     *                 _blank: Opens in the InAppBrowser.
     *                 _system: Opens in the system's web browser.
     * @param {string | InAppBrowserOptions} [options] Options for the InAppBrowser. Optional, defaulting to: location=yes.
     *                 The options string must not contain any blank space, and each feature's
     *                 name/value pairs must be separated by a comma. Feature names are case insensitive.
     */
    function InAppBrowserObject(url, target, options) {
        try {
            if (options && typeof options !== 'string') {
                options = Object.keys(options)
                    .map(function (key) { return key + "=" + options[key]; })
                    .join(',');
            }
            this._objectInstance = cordova.InAppBrowser.open(url, target, options);
        }
        catch (e) {
            if (typeof window !== 'undefined') {
                window.open(url, target);
            }
            console.warn('Native: InAppBrowser is not installed or you are running on a browser. Falling back to window.open.');
        }
    }
    InAppBrowserObject.prototype._loadAfterBeforeload = function (strUrl) { return core.cordovaInstance(this, "_loadAfterBeforeload", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.show = function () { return core.cordovaInstance(this, "show", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.close = function () { return core.cordovaInstance(this, "close", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.hide = function () { return core.cordovaInstance(this, "hide", { "sync": true }, arguments); };
    InAppBrowserObject.prototype.executeScript = function (script) { return core.cordovaInstance(this, "executeScript", {}, arguments); };
    InAppBrowserObject.prototype.insertCSS = function (css) { return core.cordovaInstance(this, "insertCSS", {}, arguments); };
    InAppBrowserObject.prototype.on = function (event) {
        var _this = this;
        return (function () {
            if (core.instanceAvailability(_this) === true) {
                return new rxjs.Observable(function (observer) {
                    _this._objectInstance.addEventListener(event, observer.next.bind(observer));
                    return function () { return _this._objectInstance.removeEventListener(event, observer.next.bind(observer)); };
                });
            }
        })();
    };
    InAppBrowserObject.prototype.on = function (event) {
        var _this = this;
        return (function () {
            if (core.instanceAvailability(_this) === true) {
                return new rxjs.Observable(function (observer) {
                    _this._objectInstance.addEventListener(event, observer.next.bind(observer));
                    return function () { return _this._objectInstance.removeEventListener(event, observer.next.bind(observer)); };
                });
            }
        })();
    };
    return InAppBrowserObject;
}());
var InAppBrowser = /** @class */ (function (_super) {
    tslib.__extends(InAppBrowser, _super);
    function InAppBrowser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Opens a URL in a new InAppBrowser instance, the current browser instance, or the system browser.
     * @param  url {string}     The URL to load.
     * @param  target {string}  The target in which to load the URL, an optional parameter that defaults to _self.
     * @param  options {string} Options for the InAppBrowser. Optional, defaulting to: location=yes.
     *                 The options string must not contain any blank space, and each feature's
     *                 name/value pairs must be separated by a comma. Feature names are case insensitive.
     * @returns {InAppBrowserObject}
     */
    InAppBrowser.prototype.create = function (url, target, options) {
        return new InAppBrowserObject(url, target, options);
    };
    InAppBrowser.pluginName = "InAppBrowser";
    InAppBrowser.plugin = "cordova-plugin-inappbrowser";
    InAppBrowser.pluginRef = "cordova.InAppBrowser";
    InAppBrowser.repo = "https://github.com/apache/cordova-plugin-inappbrowser";
    InAppBrowser.platforms = ["AmazonFire OS", "Android", "Browser", "iOS", "macOS", "Windows"];
InAppBrowser.ɵfac = function InAppBrowser_Factory(t) { return ɵInAppBrowser_BaseFactory(t || InAppBrowser); };
InAppBrowser.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: InAppBrowser, factory: function (t) { return InAppBrowser.ɵfac(t); } });
var ɵInAppBrowser_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(InAppBrowser);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InAppBrowser, [{
        type: core$1.Injectable
    }], null, null); })();
    return InAppBrowser;
}(core.IonicNativePlugin));

exports.InAppBrowser = InAppBrowser;
exports.InAppBrowserObject = InAppBrowserObject;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJidW5kbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswQkFHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgY29yZSQxID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmUgPSByZXF1aXJlKCdAaW9uaWMtbmF0aXZlL2NvcmUnKTtcbnZhciByeGpzID0gcmVxdWlyZSgncnhqcycpO1xuXG52YXIgSW5BcHBCcm93c2VyT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgVVJMIGluIGEgbmV3IEluQXBwQnJvd3NlciBpbnN0YW5jZSwgdGhlIGN1cnJlbnQgYnJvd3NlciBpbnN0YW5jZSwgb3IgdGhlIHN5c3RlbSBicm93c2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgIFRoZSBVUkwgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldD1cInNlbGZcIl0gIFRoZSB0YXJnZXQgaW4gd2hpY2ggdG8gbG9hZCB0aGUgVVJMLCBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZWZhdWx0cyB0byBfc2VsZi5cbiAgICAgKiAgICAgICAgICAgICAgICAgX3NlbGY6IE9wZW5zIGluIHRoZSBXZWJWaWV3IGlmIHRoZSBVUkwgaXMgaW4gdGhlIHdoaXRlIGxpc3QsIG90aGVyd2lzZSBpdCBvcGVucyBpbiB0aGUgSW5BcHBCcm93c2VyLlxuICAgICAqICAgICAgICAgICAgICAgICBfYmxhbms6IE9wZW5zIGluIHRoZSBJbkFwcEJyb3dzZXIuXG4gICAgICogICAgICAgICAgICAgICAgIF9zeXN0ZW06IE9wZW5zIGluIHRoZSBzeXN0ZW0ncyB3ZWIgYnJvd3Nlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IEluQXBwQnJvd3Nlck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgSW5BcHBCcm93c2VyLiBPcHRpb25hbCwgZGVmYXVsdGluZyB0bzogbG9jYXRpb249eWVzLlxuICAgICAqICAgICAgICAgICAgICAgICBUaGUgb3B0aW9ucyBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnkgYmxhbmsgc3BhY2UsIGFuZCBlYWNoIGZlYXR1cmUnc1xuICAgICAqICAgICAgICAgICAgICAgICBuYW1lL3ZhbHVlIHBhaXJzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIEZlYXR1cmUgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5BcHBCcm93c2VyT2JqZWN0KHVybCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgKyBcIj1cIiArIG9wdGlvbnNba2V5XTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29iamVjdEluc3RhbmNlID0gY29yZG92YS5JbkFwcEJyb3dzZXIub3Blbih1cmwsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmF0aXZlOiBJbkFwcEJyb3dzZXIgaXMgbm90IGluc3RhbGxlZCBvciB5b3UgYXJlIHJ1bm5pbmcgb24gYSBicm93c2VyLiBGYWxsaW5nIGJhY2sgdG8gd2luZG93Lm9wZW4uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5fbG9hZEFmdGVyQmVmb3JlbG9hZCA9IGZ1bmN0aW9uIChzdHJVcmwpIHsgcmV0dXJuIGNvcmUuY29yZG92YUluc3RhbmNlKHRoaXMsIFwiX2xvYWRBZnRlckJlZm9yZWxvYWRcIiwgeyBcInN5bmNcIjogdHJ1ZSB9LCBhcmd1bWVudHMpOyB9O1xuICAgIEluQXBwQnJvd3Nlck9iamVjdC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUuY29yZG92YUluc3RhbmNlKHRoaXMsIFwic2hvd1wiLCB7IFwic3luY1wiOiB0cnVlIH0sIGFyZ3VtZW50cyk7IH07XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUuY29yZG92YUluc3RhbmNlKHRoaXMsIFwiY2xvc2VcIiwgeyBcInN5bmNcIjogdHJ1ZSB9LCBhcmd1bWVudHMpOyB9O1xuICAgIEluQXBwQnJvd3Nlck9iamVjdC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUuY29yZG92YUluc3RhbmNlKHRoaXMsIFwiaGlkZVwiLCB7IFwic3luY1wiOiB0cnVlIH0sIGFyZ3VtZW50cyk7IH07XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5leGVjdXRlU2NyaXB0ID0gZnVuY3Rpb24gKHNjcmlwdCkgeyByZXR1cm4gY29yZS5jb3Jkb3ZhSW5zdGFuY2UodGhpcywgXCJleGVjdXRlU2NyaXB0XCIsIHt9LCBhcmd1bWVudHMpOyB9O1xuICAgIEluQXBwQnJvd3Nlck9iamVjdC5wcm90b3R5cGUuaW5zZXJ0Q1NTID0gZnVuY3Rpb24gKGNzcykgeyByZXR1cm4gY29yZS5jb3Jkb3ZhSW5zdGFuY2UodGhpcywgXCJpbnNlcnRDU1NcIiwge30sIGFyZ3VtZW50cyk7IH07XG4gICAgSW5BcHBCcm93c2VyT2JqZWN0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjb3JlLmluc3RhbmNlQXZhaWxhYmlsaXR5KF90aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb2JqZWN0SW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb2JqZWN0SW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBJbkFwcEJyb3dzZXJPYmplY3QucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNvcmUuaW5zdGFuY2VBdmFpbGFiaWxpdHkoX3RoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vYmplY3RJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vYmplY3RJbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpKTsgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbkFwcEJyb3dzZXJPYmplY3Q7XG59KCkpO1xudmFyIEluQXBwQnJvd3NlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoSW5BcHBCcm93c2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluQXBwQnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIFVSTCBpbiBhIG5ldyBJbkFwcEJyb3dzZXIgaW5zdGFuY2UsIHRoZSBjdXJyZW50IGJyb3dzZXIgaW5zdGFuY2UsIG9yIHRoZSBzeXN0ZW0gYnJvd3Nlci5cbiAgICAgKiBAcGFyYW0gIHVybCB7c3RyaW5nfSAgICAgVGhlIFVSTCB0byBsb2FkLlxuICAgICAqIEBwYXJhbSAgdGFyZ2V0IHtzdHJpbmd9ICBUaGUgdGFyZ2V0IGluIHdoaWNoIHRvIGxvYWQgdGhlIFVSTCwgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGVmYXVsdHMgdG8gX3NlbGYuXG4gICAgICogQHBhcmFtICBvcHRpb25zIHtzdHJpbmd9IE9wdGlvbnMgZm9yIHRoZSBJbkFwcEJyb3dzZXIuIE9wdGlvbmFsLCBkZWZhdWx0aW5nIHRvOiBsb2NhdGlvbj15ZXMuXG4gICAgICogICAgICAgICAgICAgICAgIFRoZSBvcHRpb25zIHN0cmluZyBtdXN0IG5vdCBjb250YWluIGFueSBibGFuayBzcGFjZSwgYW5kIGVhY2ggZmVhdHVyZSdzXG4gICAgICogICAgICAgICAgICAgICAgIG5hbWUvdmFsdWUgcGFpcnMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgYSBjb21tYS4gRmVhdHVyZSBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICAgKiBAcmV0dXJucyB7SW5BcHBCcm93c2VyT2JqZWN0fVxuICAgICAqL1xuICAgIEluQXBwQnJvd3Nlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHVybCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5BcHBCcm93c2VyT2JqZWN0KHVybCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEluQXBwQnJvd3Nlci5wbHVnaW5OYW1lID0gXCJJbkFwcEJyb3dzZXJcIjtcbiAgICBJbkFwcEJyb3dzZXIucGx1Z2luID0gXCJjb3Jkb3ZhLXBsdWdpbi1pbmFwcGJyb3dzZXJcIjtcbiAgICBJbkFwcEJyb3dzZXIucGx1Z2luUmVmID0gXCJjb3Jkb3ZhLkluQXBwQnJvd3NlclwiO1xuICAgIEluQXBwQnJvd3Nlci5yZXBvID0gXCJodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL2NvcmRvdmEtcGx1Z2luLWluYXBwYnJvd3NlclwiO1xuICAgIEluQXBwQnJvd3Nlci5wbGF0Zm9ybXMgPSBbXCJBbWF6b25GaXJlIE9TXCIsIFwiQW5kcm9pZFwiLCBcIkJyb3dzZXJcIiwgXCJpT1NcIiwgXCJtYWNPU1wiLCBcIldpbmRvd3NcIl07XG4gICAgSW5BcHBCcm93c2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZSQxLkluamVjdGFibGUgfVxuICAgIF07XG4gICAgcmV0dXJuIEluQXBwQnJvd3Nlcjtcbn0oY29yZS5Jb25pY05hdGl2ZVBsdWdpbikpO1xuXG5leHBvcnRzLkluQXBwQnJvd3NlciA9IEluQXBwQnJvd3NlcjtcbmV4cG9ydHMuSW5BcHBCcm93c2VyT2JqZWN0ID0gSW5BcHBCcm93c2VyT2JqZWN0O1xuIl19